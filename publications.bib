@inproceedings{xu2023exploration,
  author    = {Xu, Chuanqi and Erata, Ferhat and Szefer, Jakub},
  title     = {Exploration of Power Side-Channel Vulnerabilities in Quantum Computer Controllers},
  year      = {2023},
  isbn      = {9798400700507},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3576915.3623118},
  doi       = {10.1145/3576915.3623118},
  abstract  = {The rapidly growing interest in quantum computing also increases the importance of securing these computers from various physical attacks. Constantly increasing qubit counts and improvements to the fidelity of the quantum computers hold great promise for the ability of these computers to run novel algorithms with highly sensitive intellectual property. However, in today's cloud-based quantum computer setting, users lack physical control over the computers. Physical attacks, such as those perpetrated by malicious insiders in data centers, could be used to extract sensitive information about the circuits being executed on these computers. This work shows the first exploration and study of power-based side-channel attacks in quantum computers. The explored attacks could be used to recover information about the control pulses sent to these computers. By analyzing these control pulses, attackers can reverse-engineer the equivalent gate-level description of the circuits, and the algorithms being run, or data hard-coded into the circuits. This work introduces five new types of attacks, and evaluates them using control pulse information available from cloud-based quantum computers. This work demonstrates how and what circuits could be recovered, and then in turn how to defend from the newly demonstrated side-channel attacks on quantum computing systems.},
  booktitle = {Proceedings of the 2023 ACM SIGSAC Conference on Computer and Communications Security (CCS)},
  pages     = {579--593},
  numpages  = {15},
  keywords  = {power side-channel vulnerabilities, quantum computer controllers, quantum computers},
  series    = {CCS '23},
  month     = {nov}
}

@inproceedings{erata2023towards,
  title     = {Towards Automated Detection of Single-Trace Side-Channel Vulnerabilities in Constant-Time Cryptographic Code},
  author    = {Erata, Ferhat and Piskac, Ruzica and Mateu, Victor and Szefer, Jakub},
  booktitle = {2023 IEEE 8th European Symposium on Security and Privacy (EuroS&P)},
  year      = {2023},
  pages     = {687-706},
  abstract  = {Although cryptographic algorithms may be mathematically secure, it is often possible to leak secret information from the implementation of the algorithms. Timing and power side-channel vulnerabilities are some of the most widely considered threats to cryptographic algorithm implementations. Timing vulnerabilities may be easier to detect and exploit, and all high-quality cryptographic code today should be written in constant-time style. However, this does not prevent power side-channels from existing. With constant time code, potential attackers can resort to power side-channel attacks to try leaking secrets. Detecting potential power side-channel vulnerabilities is a tedious task, as it requires analyzing code at the assembly level and needs reasoning about which instructions could be leaking information based on their operands and their values. To help make the process of detecting potential power side-channel vulnerabilities easier for cryptographers, this work presents Pascal: Power Analysis Side Channel Attack Locator, a tool that introduces novel symbolic register analysis techniques for binary analysis of constant-time cryptographic algorithms, and verifies locations of potential power side-channel vulnerabilities with high precision. Pascal is evaluated on a number of implementations of post-quantum cryptographic algorithms, and it is able to find dozens of previously reported single-trace power side-channel vulnerabilities in these algorithms, all in an automated manner.},
  keywords  = {power side-channels;hamming weight;differential program analysis;post-quantum cryptography;symbolic execution;relational program analysis;binary analysis},
  doi       = {10.1109/EuroSP57164.2023.00047},
  url       = {https://doi.ieeecomputersociety.org/10.1109/EuroSP57164.2023.00047},
  publisher = {IEEE Computer Society},
  address   = {Los Alamitos, CA, USA},
  month     = {jul}
}

@article{erata2023survey,
  title     = {Survey of approaches and techniques for security verification of computer systems},
  author    = {Erata, Ferhat and Deng, Shuwen and Zaghloul, Faisal and Xiong, Wenjie and Demir, Onur and Szefer, Jakub},
  journal   = {ACM Journal on Emerging Technologies in Computing Systems (JETC)},
  abstract  = {This article surveys the landscape of security verification approaches and techniques for computer systems at various levels: from a software-application level all the way to the physical hardware level. Different existing projects are compared, based on the tools used and security aspects being examined. Since many systems require both hardware and software components to work together to provide the system’s promised security protections, it is not sufficient to verify just the software levels or just the hardware levels in a mutually exclusive fashion. This survey especially highlights system levels that are verified by the different existing projects and presents to the readers the state of the art in hardware and software system security verification. Few approaches come close to providing full-system verification, and there is still much room for&nbsp;improvement.},
  keywords  = {software-level verification, theorem provers, security verification, hardware-level verification, Formal methods, model checkers},
  url       = {https://doi.org/10.1145/3564785},
  doi       = {10.1145/3564785},
  volume    = {19},
  number    = {1},
  pages     = {1--34},
  year      = {2023},
  publisher = {ACM New York, NY}
}

@article{erata2023etap,
  title     = {ETAP: Energy-aware timing analysis of intermittent programs},
  author    = {Erata, Ferhat and Yildiz, Eren and Goknil, Arda and Yildirim, Kasim Sinan and Szefer, Jakub and Piskac, Ruzica and Sezgin, Gokcin},
  journal   = {ACM Transactions on Embedded Computing Systems (TECS)},
  url       = {https://doi.org/10.1145/3563216},
  doi       = {10.1145/3563216},
  keywords  = {symbolic execution, timing analysis, Intermittent computing, energy harvesting},
  abstract  = {Energy harvesting battery-free embedded devices rely only on ambient energy harvesting that enables stand-alone and sustainable IoT applications. These devices execute programs when the harvested ambient energy in their energy reservoir is sufficient to operate and stop execution abruptly (and start charging) otherwise. These intermittent programs have varying timing behavior under different energy conditions, hardware configurations, and program structures. This article presents Energy-aware Timing Analysis of intermittent Programs (ETAP), a probabilistic symbolic execution approach that analyzes the timing and energy behavior of intermittent programs at compile time. ETAP symbolically executes the given program while taking time and energy cost models for ambient energy and dynamic energy consumption into account. We evaluate ETAP by comparing the compile-time analysis results of our benchmark codes and real-world application with the results of their executions on real hardware. Our evaluation shows that ETAP’s prediction error rate is between 0.0076\% and 10.8\%, and it speeds up the timing analysis by at least two orders of magnitude compared to manual testing.},
  volume    = {22},
  number    = {2},
  pages     = {1--31},
  year      = {2023},
  month     = {jan},
  publisher = {ACM}
}

@inproceedings{deshpande2023design,
  title        = {Design of Quantum Computer Antivirus},
  author       = {Deshpande, Sanjay and Xu, Chuanqi and Trochatos, Theodoros and Wang, Hanrui and Erata, Ferhat and Han, Song and Ding, Yongshan and Szefer, Jakub},
  booktitle    = {2023 IEEE International Symposium on Hardware Oriented Security and Trust (HOST)},
  doi          = {10.1109/HOST55118.2023.10133711},
  url          = {https://ieeexplore.ieee.org/document/10133711},
  abstract     = {The development of quantum computers has been advancing rapidly in recent years. In addition to researchers and companies building bigger and bigger machines, these computers are already being actively connected to the internet and offered as cloud-based quantum computer services. As quantum computers become more widely accessible, potentially malicious users could try to execute their code on the machines to leak information from other users, to interfere with or manipulate results of other users, or to reverse engineer the underlying quantum computer architecture and its intellectual property, for example. To analyze such new security threats to cloud-based quantum computers, this work first proposes and explores different types of quantum computer viruses. This work shows that quantum viruses can impact outcomes of Grover’s search algorithm or machine learning classification algorithms running on quantum computers, for example. The work then proposes a first of its kind quantum computer antivirus as a new means of protecting the expensive and fragile quantum computer hardware from quantum computer viruses. The antivirus can analyze quantum computer programs, also called circuits, and detect possibly malicious ones before they execute on quantum computer hardware. As a compile-time technique, it does not introduce any new overhead at run-time of the quantum computer.},
  keywords     = {quantum computers, viruses, quantum com- puter viruses, antivirus},
  pages        = {260--270},
  year         = {2023},
  organization = {IEEE}
}

@article{xu2023classification,
  title    = {Classification of Quantum Computer Fault Injection Attacks},
  author   = {Xu, Chuanqi and Erata, Ferhat and Szefer, Jakub},
  abstract = {The rapid growth of interest in quantum computing has brought about the need to secure these powerful machines against a range of physical attacks. As qubit counts increase and quantum computers achieve higher levels of fidelity, their potential to execute novel algorithms and generate sensitive intellectual property becomes more promising. However, there is a significant gap in our understanding of the vulnerabilities these computers face in terms of security and privacy attacks. Among the potential threats are physical attacks, including those orchestrated by malicious insiders within data centers where the quantum computers are located, which could compromise the integrity of computations and resulting data. This paper presents an exploration of fault-injection attacks as one class of physical attacks on quantum computers. This work first introduces a classification of fault-injection attacks and strategies, including the domain of fault-injection attacks, the fault targets, and fault manifestations in quantum computers. The resulting classification highlights the potential threats that exist. By shedding light on the vulnerabilities of quantum computers to fault-injection attacks, this work contributes to the development of robust security measures for this emerging technology.},
  journal  = {arXiv preprint arXiv:2309.05478},
  eprint   = {2309.05478},
  doi      = {10.48550/arXiv.2309.05478},
  url      = {https://arxiv.org/abs/2309.05478},
  year     = {2023}
}

@article{azimi2023adaptv,
  title     = {AdapTV: A Model-Based Test Adaptation Approach for End-to-End User Interface Testing of Smart TVs},
  author    = {Azimi, Mohammad Yusaf and Elgun, Celal Cagin and Firat, Atil and Erata, Ferhat and Yilmaz, Cemal},
  doi       = {10.1109/ACCESS.2023.3262746},
  url       = {https://doi.org/10.1109/ACCESS.2023.3262746},
  journal   = {IEEE Access},
  volume    = {11},
  pages     = {32095--32118},
  year      = {2023},
  publisher = {IEEE}
}

@article{ozkaya2020understanding,
  title     = {Understanding practitioners' challenges on software modeling: A survey},
  author    = {Ozkaya, Mert and Erata, Ferhat},
  journal   = {Journal of Computer Languages (COLA)},
  doi       = {https://doi.org/10.1016/j.cola.2020.100963},
  url       = {https://www.sciencedirect.com/science/article/pii/S259011842030023X},
  keywords  = {model-driven software development, software modeling challenges, practitioners, survey},
  abstract  = {Software modeling is considered as the high-level design technique for describing abstract statements about software systems. While some practitioners create models for the early analysis of their design decisions and generating code from their models, some practitioners create models for the eased communication among stakeholders. There also exist practitioners who ignore modeling and directly proceed with coding. We aim in this paper to understand the challenges that practitioners face with in their software modeling activities. We surveyed 80 practitioners from 18 countries who work in 18 different industries. We focussed on 8 categories of software modeling challenges: (i) managing the language complexity, (ii) extending modeling languages, (iii) domain-specific modeling environments, (iv) developing formal modeling languages, (v) analysing models, (vi) separation of concerns, (vii) transforming models, and (viii) managing models. As the results show, the separation of concerns is the least challenging category for practitioners, while analysing models is the top challenging category. Various concrete challenges in different categories have been observed, including (i) using the modeling languages with steep learning-curve, (ii) extending the language semantics without inconsistencies and updating the language tools accordingly, (iii) evolving the DSL tools with new requirements, (iv) defining the languages’ formal semantics in terms of the translations in any formal languages, (v) decomposing models into separate viewpoints and analysing the consistencies between different viewpoint models, (vi) the consistent model transformation and the model synchronisations, (vii) using model checkers for formal analysis, and (viii) versioning models.},
  volume    = {58},
  pages     = {100963},
  year      = {2020},
  publisher = {Elsevier}
}

@article{tekinerdogan2020automated,
  title     = {Automated reasoning framework for traceability management of system of systems},
  author    = {Tekinerdogan, Bedir and Erata, Ferhat},
  journal   = {Science of Computer Programming},
  doi       = {https://doi.org/10.1016/j.scico.2020.102416},
  url       = {https://www.sciencedirect.com/science/article/pii/S0167642320300277},
  keywords  = {System of systems, Traceability, Metamodeling, Domain specific language},
  abstract  = {An important aspect in system of systems (SoS) is the realization of the capabilities in different systems that work together. Identifying and locating these capabilities are important to orchestrate the overall activities and hereby to achieve the overall goal of the SoS. System elements and capabilities in SoS however, are rarely stable and need to evolve in different ways and different times in accordance with the changing requirements. To manage the SoS and cope with its evolution it is necessary that the dependency links to the capabilities and the system elements can be easily traced. Several approaches have been proposed to model traceability and reason about these by extending a predetermined set of possible trace links with fixed semantics. However, for the context of SoS a fixed traceability model with fixed traceability semantics is limited to consider the various different and changing scenarios. In this article, we first present the different traceability requirements for managing traceability in the context of SoS. Subsequently, we present the metamodel and the corresponding domain specific language to support modeling traceability and traceability analysis approaches within the evolving SoS context. Further, we provide the tool support for automated reasoning of traceability of SoS capabilities and system elements. We illustrate and discuss the approach for the application to a smart city SoS.},
  volume    = {191},
  pages     = {102416},
  year      = {2020},
  publisher = {Elsevier}
}

@article{ozkaya2020survey,
  title     = {A survey on the practical use of UML for different software architecture viewpoints},
  author    = {Ozkaya, Mert and Erata, Ferhat},
  journal   = {Information and Software Technology},
  doi       = {https://doi.org/10.1016/j.infsof.2020.106275},
  url       = {https://www.sciencedirect.com/science/article/pii/S0950584920300252},
  keywords  = {Software architecture viewpoints, UML, Survey, Practitioners},
  abstract  = {Context Software architecture viewpoints modularize the software architectures in terms of different viewpoints that each address a different concern. Unified Modeling Language (UML) is so popular among practitioners for modeling software architectures from different viewpoints.  Objective In this paper, we aimed at understanding the practitioners’ UML usage for the modeling of software architectures from different viewpoints.  Method To this end, 109 practitioners with diverse profiles have been surveyed to understand practitioners’ UML usage for six different viewpoints: functional, information, concurrency, development, deployment, and operational. Each viewpoint has been considered in terms of a set of software models that can be created in that viewpoint.  Results The survey includes 35 questions for different viewpoint models, and the results lead to interesting findings. While the top popular viewpoints for the UML-based software architecture modeling are the functional (96%) and information (99%) viewpoints, the least popular one is the operational viewpoint that is considered by 26% of the practitioners. The top popular UML modeling tool is Enterprise Architect regardless of the viewpoints considered. Concerning the software models that can be created in each viewpoint, UML’s class diagram is practitioners’ top choice for the functional structure (71%), data structure (85%), concurrency structure (75%), software code structure (34%), and system installation (39%), and system support (16%) models; UML’s sequence diagram is the top choice for the data lifecycle models (47%); UML’s deployment diagram for the physical structure (71%), mapping between the functional and physical components (53%), and system migration (21%) models; UML’s activity diagram for the data flow (65%), software build and release processes (20–22%), and system administration (36%) models; UML’s component diagram for the mapping between the functional and concurrent components (35%), software module structure (47%), and system configuration (21%) models; and UML’s package diagram for the software module structure (47%) models.},
  volume    = {121},
  pages     = {106275},
  year      = {2020},
  publisher = {Elsevier}
}

@inproceedings{kern2019integrating,
  title        = {Integrating static code analysis toolchains},
  author       = {Kern, Matthias and Erata, Ferhat and Iser, Markus and Sinz, Carsten and Loiret, Frederic and Otten, Stefan and Sax, Eric},
  booktitle    = {2019 IEEE 43rd Annual Computer Software and Applications Conference (COMPSAC)},
  doi          = {10.1109/COMPSAC.2019.00080},
  url          = {https://ieeexplore.ieee.org/document/8754104},
  volume       = {1},
  pages        = {523--528},
  year         = {2019},
  organization = {IEEE}
}

@inproceedings{erata2018alloyinecore,
  title     = {AlloyInEcore: embedding of first-order relational logic into meta-object facility for automated model reasoning},
  author    = {Erata, Ferhat and Goknil, Arda and Kurtev, Ivan and Tekinerdogan, Bedir},
  booktitle = {Proceedings of the 2018 26th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE)},
  url       = {https://doi.org/10.1145/3236024.3264588},
  doi       = {10.1145/3236024.3264588},
  abstract  = {We present AlloyInEcore, a tool for specifying metamodels with their static semantics to facilitate automated, formal reasoning on models. Software development projects require that software systems be specified in various models (e.g., requirements models, architecture models, test models, and source code). It is crucial to reason about those models to ensure the correct and complete system specifications. AlloyInEcore~allows the user to specify metamodels with their static semantics, while, using the semantics, it automatically detects inconsistent models, and completes partial models. It has been evaluated on three industrial case studies in the automotive domain (https://modelwriter.github.io/AlloyInEcore/).},
  keywords  = {Modeling, Alloy, Relational Logic, Formal Reasoning, KodKod},
  pages     = {920--923},
  year      = {2018}
}

@inproceedings{erata2017modelwriter,
  title        = {ModelWriter: Text and model-synchronized document engineering platform},
  author       = {Erata, Ferhat and Gardent, Claire and Gyawali, Bikash and Shimorina, Anastasia and Lussaud, Yvan and Tekinerdogan, Bedir and Kardas, Geylani and Monceaux, Anne},
  booktitle    = {2017 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE)},
  pages        = {907--912},
  doi          = {10.1109/ASE.2017.8115703},
  url          = {https://ieeexplore.ieee.org/document/8115703},
  year         = {2017},
  organization = {IEEE}
}

@inproceedings{erata2017tool,
  title     = {A tool for automated reasoning about traces based on configurable formal semantics},
  author    = {Erata, Ferhat and Goknil, Arda and Tekinerdogan, Bedir and Kardas, Geylani},
  booktitle = {Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering (ESEC/FSE 2017)},
  url       = {https://doi.org/10.1145/3106237.3122825},
  doi       = {10.1145/3106237.3122825},
  abstract  = {We present Tarski, a tool for specifying configurable trace semantics to facilitate automated reasoning about traces. Software development projects require that various types of traces be modeled between and within development artifacts. For any given artifact (e.g., requirements, architecture models and source code), Tarski allows the user to specify new trace types and their configurable semantics, while, using the semantics, it automatically infers new traces based on existing traces provided by the user, and checks the consistency of traces. It has been evaluated on three industrial case studies in the automotive domain (https://modelwriter.github.io/Tarski/).},
  keywords  = {Formal Trace Semantics, Automated Reasoning, Domain-Specific Modeling, Traceability, KodKod, Alloy},
  pages     = {959--963},
  year      = {2017},
  series    = {ESEC/FSE 2017}
}

@inproceedings{erata2017tarski,
  title     = {Tarski: A platform for automated analysis of dynamically configurable traceability semantics},
  author    = {Erata, Ferhat and Challenger, Moharram and Tekinerdogan, Bedir and Monceaux, Anne and T{\"u}z{\"u}n, Eray and Kardas, Geylani},
  booktitle = {Proceedings of the Symposium on Applied Computing (SAC)},
  pages     = {1607--1614},
  year      = {2017},
  series    = {SAC '17},
  url       = {https://doi.org/10.1145/3019612.3019747},
  doi       = {10.1145/3019612.3019747},
  abstract  = {Traceability can be defined as the degree to which a relationship can be established among work products of the development process. Traceability is important to support the consistency and likewise to ensure that a system is understandable, maintainable and reliable. Several approaches have been proposed to model traceability elements and reason about them by extending a predetermined set of possible trace links with fixed semantics. Furthermore, they do not cope with the need for dynamic adaptation and configuration of traceability semantics. However, different project types usually require various ways of tracing the system to obtain richer and precise automated traceability analysis. In this paper, we introduce a novel approach with its supporting platform which enables the user to rigorously configure the system based on project-specific needs and interactively specify the semantics of traceability elements. The semantics of traceability elements are formalized using first-order relational logic, which are used to facilitate different form of automated analysis. The use of the proposed approach and the corresponding tool is described within the context of an industrial application lifecycle management process.},
  keywords  = {traceability, alloy, automated analysis, formal trace semantics, KodKod, domain-specific modeling}
}

@inproceedings{tekinerdogan2017modeling,
  title     = {Modeling traceability in system of systems},
  author    = {Tekinerdogan, Bedir and Erata, Ferhat},
  booktitle = {Proceedings of the Symposium on Applied Computing (SAC)},
  url       = {https://doi.org/10.1145/3019612.3019908},
  doi       = {10.1145/3019612.3019908},
  abstract  = {An important aspect in SoS is the realization of the concerns in different systems that work together. Identifying and locating these concerns is important to orchestrate the overall activities and hereby to achieve the overall goal of the SoS. Moreover, concerns in SoS are rarely stable and need to evolve in different ways and different times in accordance with the changing requirements. To manage the SoS and cope with the evolution of concerns it is necessary that the dependency links between the concerns and the system elements can be easily traced. In this paper, we present the different traceability requirements and the corresponding metamodel to support modeling traceability and supporting traceability analysis approaches within the SoS context.},
  keywords  = {metamodel, system of systems, traceability},
  pages     = {1799--1802},
  year      = {2017},
  series    = {SAC '17}
}